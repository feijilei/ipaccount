/***************************************************************************
 *   This is a module which is used for counting packets.                  *
 *   See http://www.intra2net.com/opensource/ipt_account                   *
 *   for further information                                               *
 *                                                                         *
 *   Copyright (C) 2004-2011 by Intra2net AG                               *
 *   opensource@intra2net.com                                              *
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License                  *
 *   version 2 as published by the Free Software Foundation;               *
 *                                                                         *
 ***************************************************************************/


/*
 *   Author:      yubo <yubo@xiaomi.com> 
 *                This program is free software; you can redistribute it and/or
 *                modify it under the terms of the GNU General Public License
 *                as published by the Free Software Foundation; either version
 *                2 of the License, or (at your option) any later version.
 **/


 


#include <linux/module.h>   /* Needed by all modules */
#include <linux/kernel.h>   /* Needed for KERN_ALERT */
#include <linux/version.h>
#include <linux/skbuff.h>
#include <linux/ip.h>
#include <linux/init.h>
#include <linux/types.h>
#include <linux/capability.h>
#include <linux/fs.h>
#include <linux/sysctl.h>
#include <linux/proc_fs.h>
#include <linux/swap.h>
#include <linux/mm.h>
#include <linux/string.h>
#include <linux/spinlock.h>
#include <linux/if_vlan.h>
#include <linux/netfilter.h>
#include <linux/netfilter_ipv4.h>
#include <linux/mutex.h>

#include <net/route.h>
#include <net/sock.h>
#include <net/genetlink.h>
#include <net/icmp.h>
#include <net/udp.h>
#include <net/tcp.h>

#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,27)
    #include <linux/semaphore.h>
#else
    #include <asm/semaphore.h>
#endif

#include <asm/uaccess.h>

#include "ip_account.h"


#if (PAGE_SIZE < 4096)
#error "ip_ACCOUNT needs at least a PAGE_SIZE of 4096"
#endif


/* Spinlock used for manipulating the current accounting tables/data */
static DEFINE_SPINLOCK(ip_acc_lock);

/* lock for table */
//static DEFINE_RWLOCK(__ip_acc_table_lock);
/* Mutex (semaphore) used for manipulating userspace handles/snapshot data */
static struct semaphore ip_acc_userspace_mutex;



/**
 * Internal table structure, generated by check_entry()
 * @name:	name of the table
 * @ip:		base IP address of the network
 * @mask:	netmask of the network
 * @depth:	size of network (0: 8-bit, 1: 16-bit, 2: 24-bit)
 * @refcount:	refcount of the table; if zero, destroy it
 * @itemcount:	number of IP addresses in this table
 * @data;	pointer to the actual data, depending on netmask
 */
struct ip_acc_table {
	char name[ACCOUNT_TABLE_NAME_LEN];
	__be32 ip;
	__be32 net;
	__be32 netmask;
	uint8_t depth;
	uint32_t refcount;
	uint32_t itemcount;
	void *data;
};

/**
 * Internal handle structure
 * @ip:		base IP address of the network. Used for caculating the final
 * 		address during get_data().
 * @depth:	size of the network; see above
 * @itemcount:	number of addresses in this table
 */
struct ip_acc_handle {
	uint32_t ip;
	uint8_t depth;
	uint32_t itemcount;
	void *data;
};


/* Used for every IP entry
   Size is 16 bytes so that 256 (class C network) * 16
   fits in one kernel (zero) page */
struct ip_acc_ip {
	uint32_t src_packets;
	uint32_t src_bytes;
	uint32_t dst_packets;
	uint32_t dst_bytes;
};

/*
 *	The IP addresses are organized as an array so that direct slot
 *	calculations are possible.
 *	Only 8-bit networks are preallocated, 16/24-bit networks
 *	allocate their slots when needed -> very efficent.
 */
struct ip_acc_mask_24 {
	struct ip_acc_ip ip[256];
};

struct ip_acc_mask_16 {
	struct ip_acc_mask_24 *mask_24[256];
};

struct ip_acc_mask_8 {
	struct ip_acc_mask_16 *mask_16[256];
};

static struct ip_acc_table *ip_acc_tables;
static struct ip_acc_handle *ip_acc_handles;







/* Allocates a page and clears it */
static void *ip_acc_zalloc_page(void)
{
	// Don't use get_zeroed_page until it's fixed in the kernel.
	// get_zeroed_page(GFP_ATOMIC)
	void *mem = (void *)__get_free_page(GFP_ATOMIC);
	if (mem) {
		memset (mem, 0, PAGE_SIZE);
	}

	return mem;
}

/* Recursive free of all data structures */
static void ip_acc_data_free(void *data, uint8_t depth)
{
	/* Empty data set */
	if (!data)
		return;

	/* Free for 8 bit network */
	if (depth == 0) {
		free_page((unsigned long)data);
		return;
	}

	/* Free for 16 bit network */
	if (depth == 1) {
		struct ip_acc_mask_16 *mask_16 = data;
		unsigned int b;
		for (b = 0; b <= 255; b++) {
			if (mask_16->mask_24[b]) {
				free_page((unsigned long)mask_16->mask_24[b]);
			}
		}
		free_page((unsigned long)data);
		return;
	}

	/* Free for 24 bit network */
	if (depth == 2) {
		unsigned int a, b;
		for (a = 0; a <= 255; a++) {
			if (((struct ip_acc_mask_8 *)data)->mask_16[a]) {
				struct ip_acc_mask_16 *mask_16 =
					((struct ip_acc_mask_8 *)data)->mask_16[a];

				for (b = 0; b <= 255; b++) {
					if (mask_16->mask_24[b]) {
						free_page((unsigned long)mask_16->mask_24[b]);
					}
				}
				free_page((unsigned long)mask_16);
			}
		}
		free_page((unsigned long)data);
		return;
	}

	printk("IPACCOUNT: ip_acc_data_free called with unknown depth: %d\n",
		depth);
	return;
}





/*
extern void register_skb_accounter(int (*rx)(const struct sk_buff *skb),
	int (*tx)(const struct sk_buff *skb));

extern void unregister_skb_accounter(void);
*/

static void ip_acc_depth0_insert(struct ip_acc_mask_24 *mask_24,
				  __be32 net_ip, __be32 netmask,
				  __be32 src_ip, __be32 dst_ip,
				   uint32_t size, uint32_t *itemcount, bool is_src)
{
	uint8_t src_slot, dst_slot;
	bool is_dst = false;
	/* Check if this entry is new */
	bool is_src_new_ip = false, is_dst_new_ip = false;

	is_dst = is_src ? false : true;

	dLog("IPACCOUNT: ip_acc_depth0_insert: %pI4/%pI4 "
		"for net %pI4/%pI4, size: %u\n", &src_ip,
		&dst_ip, &net_ip, &netmask, size);

	/* Check if src/dst is inside our network. */
	/* Special: net_ip = 0.0.0.0/0 gets stored as src in slot 0 */
	if (netmask == 0){
		src_ip = 0;
	}

	/* Calculate array positions */
	src_slot = ntohl(src_ip) & 0xFF;
	dst_slot = ntohl(dst_ip) & 0xFF;

	/* Increase size counters */
	if (is_src) {
		/* Calculate network slot */
		dLog("IPACCOUNT: Calculated SRC 8 bit network slot: %d\n", src_slot);
		if (!mask_24->ip[src_slot].src_packets
		    && !mask_24->ip[src_slot].dst_packets)
			is_src_new_ip = true;

		mask_24->ip[src_slot].src_packets++;
		mask_24->ip[src_slot].src_bytes += size;
	}
	if (is_dst) {
		dLog("IPACCOUNT: Calculated DST 8 bit network slot: %d\n", dst_slot);
		if (!mask_24->ip[dst_slot].src_packets
		    && !mask_24->ip[dst_slot].dst_packets)
			is_dst_new_ip = true;

		mask_24->ip[dst_slot].dst_packets++;
		mask_24->ip[dst_slot].dst_bytes += size;
	}

	/* Increase itemcounter */
	dLog("IPACCOUNT: Itemcounter before: %d\n", *itemcount);
	if (src_slot == dst_slot) {
		if (is_src_new_ip || is_dst_new_ip) {
			dLog("IPACCOUNT: src_slot == dst_slot: %d, %d\n",
				is_src_new_ip, is_dst_new_ip);
			++*itemcount;
		}
	} else {
		if (is_src_new_ip) {
			dLog("IPACCOUNT: New src_ip: %pI4\n", &src_ip);
			++*itemcount;
		}
		if (is_dst_new_ip) {
			dLog("IPACCOUNT: New dst_ip: %pI4\n", &dst_ip);
			++*itemcount;
		}
	}
	dLog("IPACCOUNT: Itemcounter after: %d\n", *itemcount);
}

static void ip_acc_depth1_insert(struct ip_acc_mask_16 *mask_16,
				  __be32 net_ip, __be32 netmask,
				  __be32 src_ip, __be32 dst_ip,
				uint32_t size, uint32_t *itemcount, bool is_src)
{
	/* Do we need to process src IP? */
	if (is_src) {
		uint8_t slot = (ntohl(src_ip) & 0xFF00) >> 8;
		dLog("IPACCOUNT: Calculated SRC 16 bit network slot: %d\n", slot);

		/* Do we need to create a new mask_24 bucket? */
		if (!mask_16->mask_24[slot] && (mask_16->mask_24[slot] =
		    ip_acc_zalloc_page()) == NULL) {
			eLog("IPACCOUNT: Can't process packet because out of memory!\n");
			return;
		}

		ip_acc_depth0_insert(mask_16->mask_24[slot],
			net_ip, netmask, src_ip, dst_ip, size, itemcount, is_src);
	} else {
		uint8_t slot = (ntohl(dst_ip) & 0xFF00) >> 8;
		dLog("IPACCOUNT: Calculated DST 16 bit network slot: %d\n", slot);

		/* Do we need to create a new mask_24 bucket? */
		if (!mask_16->mask_24[slot] && (mask_16->mask_24[slot]
		    = ip_acc_zalloc_page()) == NULL) {
			eLog("IPACCOUNT: Can't process packet because out of memory!\n");
			return;
		}

		ip_acc_depth0_insert(mask_16->mask_24[slot],
			net_ip, netmask, src_ip, dst_ip, size, itemcount, is_src);
	}
}

static void ip_acc_depth2_insert(struct ip_acc_mask_8 *mask_8,
				  __be32 net_ip, __be32 netmask,
				  __be32 src_ip, __be32 dst_ip,
				uint32_t size, uint32_t *itemcount, bool is_src)
{
	/* Do we need to process src IP? */
	if (is_src) {
		uint8_t slot = (ntohl(src_ip) & 0xFF0000) >> 16;
		dLog("IPACCOUNT: Calculated SRC 24 bit network slot: %d\n", slot);

		/* Do we need to create a new mask_24 bucket? */
		if (!mask_8->mask_16[slot] && (mask_8->mask_16[slot]
		    = ip_acc_zalloc_page()) == NULL) {
			printk("IPACCOUNT: Can't process packet because out of memory!\n");
			return;
		}

		ip_acc_depth1_insert(mask_8->mask_16[slot],
			net_ip, netmask, src_ip, dst_ip, size, itemcount, is_src);
	} else {
		uint8_t slot = (ntohl(dst_ip) & 0xFF0000) >> 16;
		dLog("IPACCOUNT: Calculated DST 24 bit network slot: %d\n", slot);

		/* Do we need to create a new mask_24 bucket? */
		if (!mask_8->mask_16[slot] && (mask_8->mask_16[slot]
		    = ip_acc_zalloc_page()) == NULL) {
			printk("IPACCOUNT: Can't process packet because out of memory!\n");
			return;
		}

		ip_acc_depth1_insert(mask_8->mask_16[slot],
			net_ip, netmask, src_ip, dst_ip, size, itemcount, is_src);
	}
}



static unsigned int ip_acc_target(__be32 src_ip, __be32 dst_ip,
	uint32_t size, int32_t nr, bool is_src)
{


	spin_lock_bh(&ip_acc_lock);
	
	/* 8 bit network or "any" network */
	if (ip_acc_tables[nr].depth == 0) {
		/* Count packet and check if the IP is new */
		ip_acc_depth0_insert(
			ip_acc_tables[nr].data,
			ip_acc_tables[nr].ip,
			ip_acc_tables[nr].netmask,
			src_ip, dst_ip, size, &ip_acc_tables[nr].itemcount, is_src);
		spin_unlock_bh(&ip_acc_lock);
		return 0;
	}

	/* 16 bit network */
	if (ip_acc_tables[nr].depth == 1) {
		ip_acc_depth1_insert(
			ip_acc_tables[nr].data,
			ip_acc_tables[nr].ip,
			ip_acc_tables[nr].netmask,
			src_ip, dst_ip, size, &ip_acc_tables[nr].itemcount, is_src);
		spin_unlock_bh(&ip_acc_lock);
		return 0;
	}

	/* 24 bit network */
	if (ip_acc_tables[nr].depth == 2) {
		ip_acc_depth2_insert(
			ip_acc_tables[nr].data,
			ip_acc_tables[nr].ip,
			ip_acc_tables[nr].netmask,
			src_ip, dst_ip, size, &ip_acc_tables[nr].itemcount, is_src);
		spin_unlock_bh(&ip_acc_lock);
		return 0;
	}

	eLog("IPACCOUNT: ipt_acc_target: Unable to process packet. "
		"Table id %u. IPs %pI4/%pI4\n",
		nr, &src_ip, &dst_ip);	
	spin_unlock_bh(&ip_acc_lock);
	return 0;


}


static int _skb_rx_accounter(const struct sk_buff *skb)
{
	struct iphdr *iph = NULL;
	__be32 src_ip, dst_ip;
	uint32_t size;
	struct ethhdr *eth;
	struct vlan_hdr *vlanhdr;
	int i;
	bool is_src;



	if (skb->data_len){
		dLog("%s: skb->data_len:%d\n", __func__, skb->data_len);
		return 0;
	}

	eth = (struct ethhdr *)(skb->data - sizeof(struct ethhdr));

	switch ntohs(eth->h_proto) {
		case ETH_P_8021Q:
			vlanhdr = (struct vlan_hdr *)(eth+1);
			if (vlanhdr->h_vlan_encapsulated_proto == htons(ETH_P_IP)) {
				iph = (struct iphdr *)(vlanhdr+1);
			}			
			break;
			
		case ETH_P_IP:
			iph = (struct iphdr *)skb->data;
			break;

		case ETH_P_IPV6:
			return 0;
			break;

		case ETH_P_PPP_DISC:
		case ETH_P_PPP_SES:
		case ETH_P_ARP:
		case 0x0069:
		case 0x88cc:	/**/
			return 0;
			break;
		default:
			dLog("%s: proto:%04x\n", __func__, ntohs(eth->h_proto));
			return 0;
			break;
	}

	
	src_ip = iph->saddr;
	dst_ip = iph->daddr;
	size = ntohs(iph->tot_len);
#if 0	
	dLog("IPACCOUNT: %s size[%d]"
		"IPs %pI4-->%pI4\n",
		__func__, size, &src_ip, &dst_ip);
#endif
	//find src
	if (ip_acc_tables[0].name[0] == 0)
		return 0;

	if ((ip_acc_tables[0].net == (src_ip & ip_acc_tables[0].netmask)) && 
		(ip_acc_tables[0].net != (dst_ip & ip_acc_tables[0].netmask))){
		//lan->wan
		is_src = true;
		ip_acc_target(src_ip, dst_ip, size, 0, is_src);



		//find dst(wan)
		for (i = 1; i < ACCOUNT_MAX_TABLES; i++) {
			/* Found free slot */
			if (ip_acc_tables[i].name[0] == 0)
				continue;
			if (ip_acc_tables[i].net == (dst_ip & ip_acc_tables[i].netmask)){
				// find it
				is_src = false;
				ip_acc_target(src_ip, dst_ip, size, i, is_src);
				return 0;
			}
		}


		
	}

#if 0
	printk("IPACCOUNT: %s size[%d]"
		"IPs %pI4-->%pI4\n",
		__func__, size, &src_ip, &dst_ip);
#endif
	return 0;

}



static int _skb_tx_accounter(const struct sk_buff *skb)
{
	int i;
	__be32 src_ip = ip_hdr(skb)->saddr;
	__be32 dst_ip = ip_hdr(skb)->daddr;
	uint32_t size = ntohs(ip_hdr(skb)->tot_len);
	bool is_src;
#if 0

	dLog("IPACCOUNT: %s size[%d]"
		"IPs %pI4-->%pI4\n",
		__func__, size, &src_ip, &dst_ip);
#endif
	//find dst
	if (ip_acc_tables[0].name[0] == 0)
		return 0;

	if ((ip_acc_tables[0].net == (dst_ip & ip_acc_tables[0].netmask)) && 
		(ip_acc_tables[0].net != (src_ip & ip_acc_tables[0].netmask))){
		//wan->lan
		is_src = false;
		ip_acc_target(src_ip,dst_ip,size,0,is_src);

		//find src(wan)
		for (i = 1; i < ACCOUNT_MAX_TABLES; i++) {
			/* Found free slot */
			if (ip_acc_tables[i].name[0] == 0)
				continue;
			
			if (ip_acc_tables[i].net == (src_ip & ip_acc_tables[i].netmask)){
				// find it
				is_src = true;
				ip_acc_target(src_ip, dst_ip, size, i, is_src);
				return 0;
			}
		}		
	}

	return 0;

}





/*
 * Generic Netlink interface
 */

/* IPVS genetlink family */
static struct genl_family ip_acc_genl_family = {
    .id = GENL_ID_GENERATE,
    .hdrsize = 0,
    .name = IPACC_GENL_NAME,
    .version = IPACC_GENL_VERSION,
    .maxattr = IPACC_CMD_MAX,
};


/* Policy used for attributes in nested attribute IPACC_CMD_ATTR */
static const struct nla_policy ip_acc_cmd_policy[IPACC_CMD_ATTR_MAX + 1] = {
    [IPACC_CMD_ATTR_TABLE] = {.type = NLA_NESTED},
    [IPACC_CMD_ATTR_IP] = {.type = NLA_NESTED},
    [IPACC_CMD_ATTR_HANDLE_NR] = {.type = NLA_U32},
    
};

/* Policy used for attributes in nested attribute IPACC_CMD_ATTR_TABLE */
static const struct nla_policy ip_acc_table_policy[IPACC_TABLE_ATTR_MAX + 1] = {
    [IPACC_TABLE_ATTR_NET_IP] = {.type = NLA_U32},
    [IPACC_TABLE_ATTR_NET_MASK] = {.type = NLA_U32},
    [IPACC_TABLE_ATTR_NAME] = {.type = NLA_NUL_STRING,
                    .len = ACCOUNT_TABLE_NAME_LEN},
    [IPACC_TABLE_ATTR_NR] = {.type = NLA_U32},
};

/* Policy used for attributes in nested attribute IPACC_CMD_ATTR_NODE */
static const struct nla_policy ip_acc_ip_policy[IPACC_IP_ATTR_MAX + 1] = {
    [IPACC_IP_ATTR_IP] = {.type = NLA_U32},
    [IPACC_IP_ATTR_SRC_PACKETS] = {.type = NLA_U32},
    [IPACC_IP_ATTR_SRC_BYTES] = {.type = NLA_U32},
    [IPACC_IP_ATTR_DST_PACKETS] = {.type = NLA_U32},
    [IPACC_IP_ATTR_DST_BYTES] = {.type = NLA_U32},
};


static int ip_acc_genl_parse_table(struct ip_acc_table_user_kern *uitb,
				    struct nlattr *nla, int full_entry)
{
	struct nlattr *attrs[IPACC_TABLE_ATTR_MAX + 1];
	struct nlattr *nla_name;

	EnterFunction();

	/* Parse mandatory identifying service fields first */
	if (nla == NULL ||
	    nla_parse_nested(attrs, IPACC_TABLE_ATTR_MAX, nla, ip_acc_table_policy))
		return -EINVAL;

	nla_name = attrs[IPACC_TABLE_ATTR_NAME];

	if (!nla_name)
		return -EINVAL;
	
	memset(uitb, 0, sizeof(*uitb));
	
	uitb->table_name = nla_data(nla_name);

	dLog("ip_acc_genl_parse_table: table_name [%s]\n", uitb->table_name);

	if (full_entry) {
		struct nlattr *nla_ip, *nla_mask;
		nla_ip = attrs[IPACC_TABLE_ATTR_NET_IP];
		nla_mask = attrs[IPACC_TABLE_ATTR_NET_MASK];
		if (!(nla_ip && nla_mask))
			return -EINVAL;	
		uitb->net_ip= nla_get_u32(nla_ip);
		uitb->net_mask= nla_get_u32(nla_mask);		
	}
	return 0;
}

static int ip_acc_add_table(int *nr, struct ip_acc_table_user_kern *u)
{
	int i;

	EnterFunction();

	dLog("IPACCOUNT: ipt_acc_table_insert: %s, %pI4/%pI4\n",
			u->table_name, &u->net_ip, &u->net_mask);

	/* Insert new table */
	for (i = (*nr < 0) ? 0 : *nr; i < ACCOUNT_MAX_TABLES; i++) {
		/* Found free slot */
		if (ip_acc_tables[i].name[0] == 0) {
			unsigned int netsize = 0;
			uint32_t calc_mask;
			int j;  /* needs to be signed, otherwise we risk endless loop */

			dLog("IPACCOUNT: Found free slot: %d\n", i);
			strncpy(ip_acc_tables[i].name, u->table_name, ACCOUNT_TABLE_NAME_LEN-1);

			ip_acc_tables[i].ip = u->net_ip;
			ip_acc_tables[i].netmask = u->net_mask;
			ip_acc_tables[i].net = u->net_ip & u->net_mask;

			/* Calculate netsize */
			calc_mask = htonl(u->net_mask);
			for (j = 31; j >= 0; j--) {
				if (calc_mask & (1 << j))
					netsize++;
				else
					break;
			}

			/* Calculate depth from netsize */
			if (netsize >= 24)
				ip_acc_tables[i].depth = 0;
			else if (netsize >= 16)
				ip_acc_tables[i].depth = 1;
			else if (netsize >= 8)
				ip_acc_tables[i].depth = 2;

			dLog("IPACCOUNT: calculated netsize: %u -> "
				"ipt_acc_table depth %u\n", netsize,
				ip_acc_tables[i].depth);

			ip_acc_tables[i].refcount++;
			if ((ip_acc_tables[i].data
			    = ip_acc_zalloc_page()) == NULL) {
				printk("IPACCOUNT: out of memory for data of table: %s\n", u->table_name);
				memset(&ip_acc_tables[i], 0,
					sizeof(struct ip_acc_table));
				return -1;
			}
			*nr = i;
			return 0;
		}
	}

	/* No free slot found */
	printk("IPACCOUNT: No free table slot found (max: %d). "
		"Please increase ACCOUNT_MAX_TABLES.\n", ACCOUNT_MAX_TABLES);
	return -1;

}





static int ip_acc_del_table(int nr)
{
	int ret = 0;
	EnterFunction();
	
	
	dLog("IPACCOUNT: %s called for table: %s (#%d)\n",
		__func__, ip_acc_tables[nr].name, nr);
	ip_acc_data_free(ip_acc_tables[nr].data,
		ip_acc_tables[nr].depth);
	memset(&ip_acc_tables[nr], 0,
		sizeof(struct ip_acc_table));	
	return ret;

}

static void ip_acc_destroy(void)
{
	unsigned int i;
	int nr;

	spin_lock_bh(&ip_acc_lock);

	nr = -1;	/* Set back to original state */

	/* Look for table */
	for (i = 0; i < ACCOUNT_MAX_TABLES; i++) {
		ip_acc_del_table(i);
	}

	spin_unlock_bh(&ip_acc_lock);
}

static int ip_acc_set_table(int table_nr, struct ip_acc_table_user_kern *u)
{	
	ip_acc_del_table(table_nr);
	return ip_acc_add_table(&table_nr, u);
}


static inline int __ip_acc_table_get(const char *name)
{
	unsigned int i;
	EnterFunction();
	for (i = 0; i < ACCOUNT_MAX_TABLES; i++) {
		if (strncmp(ip_acc_tables[i].name, name,
			ACCOUNT_TABLE_NAME_LEN) == 0) {
			dLog("IPACCOUNT: Found existing slot: %d - "
				"%pI4/%pI4\n", i,
				&(ip_acc_tables[i].ip),
				&(ip_acc_tables[i].netmask));

			return i;
		}
	}

	return -1;
}

static int ip_acc_handle_find_slot(void)
{
	unsigned int i;
	/* Insert new table */
	for (i = 0; i < ACCOUNT_MAX_HANDLES; i++) {
		/* Found free slot */
		if (ip_acc_handles[i].data == NULL) {
			/* Don't "mark" data as used as we are protected by a spinlock
			   by the calling function. handle_find_slot() is only a function
			   to prevent code duplication. */
			return i;
		}
	}

	/* No free slot found */
	eLog("ACCOUNT: No free handle slot found (max: %u). "
		"Please increase ACCOUNT_MAX_HANDLES.\n", ACCOUNT_MAX_HANDLES);
	return -1;
}

static int ip_acc_handle_free(unsigned int handle)
{
	if (handle >= ACCOUNT_MAX_HANDLES) {
		printk("ACCOUNT: Invalid handle for ipt_acc_handle_free() specified:"
			" %u\n", handle);
		return -EINVAL;
	}

	ip_acc_data_free(ip_acc_handles[handle].data,
		ip_acc_handles[handle].depth);
	memset(&ip_acc_handles[handle], 0, sizeof(struct ip_acc_handle));
	return 0;
}



/* Prepare data for read without flush. Use only for debugging!
   Real applications should use read&flush as it's way more efficent */
static int ip_acc_handle_prepare_read(int table_nr,
		 struct ip_acc_handle *dest)
{
	uint8_t depth;


	/* Fill up handle structure */
	dest->ip = ip_acc_tables[table_nr].ip;
	dest->depth = ip_acc_tables[table_nr].depth;
	dest->itemcount = ip_acc_tables[table_nr].itemcount;

	/* allocate "root" table */
	if ((dest->data = ip_acc_zalloc_page()) == NULL) {
		eLog("ACCOUNT: out of memory for root table "
			"in ipt_acc_handle_prepare_read()\n");
		return -1;
	}

	/* Recursive copy of complete data structure */
	depth = dest->depth;
	if (depth == 0) {
		memcpy(dest->data,
			ip_acc_tables[table_nr].data,
			sizeof(struct ip_acc_mask_24));
	} else if (depth == 1) {
		struct ip_acc_mask_16 *src_16 =
			ip_acc_tables[table_nr].data;
		struct ip_acc_mask_16 *network_16 = dest->data;
		unsigned int b;

		for (b = 0; b <= 255; b++) {
			if (src_16->mask_24[b]) {
				if ((network_16->mask_24[b] =
				    ip_acc_zalloc_page()) == NULL) {
					eLog("ACCOUNT: out of memory during copy of 16 bit "
						"network in ipt_acc_handle_prepare_read()\n");
					ip_acc_data_free(dest->data, depth);
					return -1;
				}

				memcpy(network_16->mask_24[b], src_16->mask_24[b],
					sizeof(struct ip_acc_mask_24));
			}
		}
	} else if (depth == 2) {
		struct ip_acc_mask_8 *src_8 =
			ip_acc_tables[table_nr].data;
		struct ip_acc_mask_8 *network_8 = dest->data;
		struct ip_acc_mask_16 *src_16, *network_16;
		unsigned int a, b;

		for (a = 0; a <= 255; a++) {
			if (src_8->mask_16[a]) {
				if ((network_8->mask_16[a] =
				    ip_acc_zalloc_page()) == NULL) {
					eLog("ACCOUNT: out of memory during copy of 24 bit network"
						" in ipt_acc_handle_prepare_read()\n");
					ip_acc_data_free(dest->data, depth);
					return -1;
				}

				memcpy(network_8->mask_16[a], src_8->mask_16[a],
					sizeof(struct ip_acc_mask_16));

				src_16 = src_8->mask_16[a];
				network_16 = network_8->mask_16[a];

				for (b = 0; b <= 255; b++) {
					if (src_16->mask_24[b]) {
						if ((network_16->mask_24[b] =
						    ip_acc_zalloc_page()) == NULL) {
							eLog("ACCOUNT: out of memory during copy of 16 bit"
								" network in ipt_acc_handle_prepare_read()\n");
							ip_acc_data_free(dest->data, depth);
							return -1;
						}

						memcpy(network_16->mask_24[b], src_16->mask_24[b],
							sizeof(struct ip_acc_mask_24));
					}
				}
			}
		}
	}

	return 0;
}


/* Prepare data for read and flush it */
static int ip_acc_handle_prepare_read_flush(int table_nr,
			   struct ip_acc_handle *dest)
{
	void *new_data_page;


	/* Try to allocate memory */
	if (!(new_data_page = ip_acc_zalloc_page())) {
		eLog("ACCOUNT: ipt_acc_handle_prepare_read_flush(): "
			"Out of memory!\n");
		return -1;
	}

	/* Fill up handle structure */
	dest->ip = ip_acc_tables[table_nr].ip;
	dest->depth = ip_acc_tables[table_nr].depth;
	dest->itemcount = ip_acc_tables[table_nr].itemcount;
	dest->data = ip_acc_tables[table_nr].data;

	/* "Flush" table data */
	ip_acc_tables[table_nr].data = new_data_page;
	ip_acc_tables[table_nr].itemcount = 0;

	return 0;
}


static int ip_acc_genl_get_cmd(struct sk_buff *skb, struct genl_info *info){
	int nr = -1;
	struct ip_acc_table_user_kern uitb;
	struct ip_acc_handle_opt handle;
	struct sk_buff *msg;
	void *reply;
	
	int ret = 0, cmd, reply_cmd;
	EnterFunction();

	cmd = info->genlhdr->cmd;


	dLog("IPACCOUNT: %s cmd: (%d)\n",
		__func__, cmd);
	if (	cmd == IPACC_CMD_GET_IPS_PRE ||
		cmd == IPACC_CMD_GET_IPS_PRE_FLUSH){
		reply_cmd = IPACC_CMD_SET_HANDLE;
	} else {
		eLog("unknown Generic Netlink command\n");
		return -EINVAL;
	}


	msg = nlmsg_new(NLMSG_DEFAULT_SIZE, GFP_KERNEL);
	if (!msg)
		return -ENOMEM;


	spin_lock_bh(&ip_acc_lock);

	reply = genlmsg_put_reply(msg, info, &ip_acc_genl_family, 0, reply_cmd);
	if (reply == NULL)
		goto nla_put_failure;





	switch (cmd){
	case IPACC_CMD_GET_IPS_PRE:
	case IPACC_CMD_GET_IPS_PRE_FLUSH:
	{
		struct ip_acc_handle dest;

		ret = ip_acc_genl_parse_table(&uitb,
			       info->attrs[IPACC_CMD_ATTR_TABLE],
			       (cmd == IPACC_CMD_SET_TABLE) ? 1 : 0);
		if (ret)
			goto out_err;
		
		
		nr = __ip_acc_table_get(uitb.table_name);
		if(nr == -1){
			ret = -ESRCH;
			goto out_err;
		}

		
		if (cmd == IPACC_CMD_GET_IPS_PRE_FLUSH)
			ret = ip_acc_handle_prepare_read_flush(
				nr, &dest);
		else
			ret = ip_acc_handle_prepare_read(
				nr, &dest);
		// Error occured during prepare_read?
		if (ret == -1){
			ret = -EINVAL;
			goto out_err;
		}
		
		
		/* Allocate a userspace handle */
		down(&ip_acc_userspace_mutex);
		if ((handle.handle_nr = ip_acc_handle_find_slot()) == -1) {
			ip_acc_data_free(dest.data, dest.depth);
			up(&ip_acc_userspace_mutex);
			return -EINVAL;
		}
		memcpy(&ip_acc_handles[handle.handle_nr], &dest,
			sizeof(struct ip_acc_handle));
		up(&ip_acc_userspace_mutex);


		NLA_PUT_U32(msg, IPACC_CMD_ATTR_HANDLE_NR,
				    handle.handle_nr);
		break;
	}
	/*
	case IPACC_CMD_DEL_TABLE:
		ret = ip_acc_del_table(nr);
		break;
	*/
	}


	genlmsg_end(msg, reply);
	ret = genlmsg_reply(msg, info);
	goto out;	

nla_put_failure:
	pr_err("not enough space in Netlink message\n");
	ret = -EMSGSIZE;

out_err:
	nlmsg_free(msg);

out:
	spin_unlock_bh(&ip_acc_lock);

	LeaveFunction();
	dLog("%s ret: %d\n",__func__,  ret);
	return ret;
	
}


static int ip_acc_genl_set_table(struct sk_buff *skb, struct genl_info *info){
	int nr = -1;
	struct ip_acc_table_user_kern uitb;
	
	int ret = 0, cmd;
	EnterFunction();

	cmd = info->genlhdr->cmd;

	spin_lock_bh(&ip_acc_lock);


	ret = ip_acc_genl_parse_table(&uitb,
		       info->attrs[IPACC_CMD_ATTR_TABLE],
		       1);
	if (ret)
		goto out;


	nr = __ip_acc_table_get(uitb.table_name);

	if ( nr == -1)
		ret = -ESRCH;
	else
		ret = ip_acc_set_table(nr, &uitb);


out:
	spin_unlock_bh(&ip_acc_lock);
	LeaveFunction();
	dLog("%s ret: %d\n",__func__,  ret);
	return ret;
	
}


static int ip_acc_genl_del_table(struct sk_buff *skb, struct genl_info *info){
	int nr = -1;
	struct ip_acc_table_user_kern uitb;
	
	int ret = 0, cmd;
	EnterFunction();

	cmd = info->genlhdr->cmd;

	spin_lock_bh(&ip_acc_lock);
	dLog("IPACCOUNT: %s cmd: (%d)\n",
		__func__, cmd);


	ret = ip_acc_genl_parse_table(&uitb,
		       info->attrs[IPACC_CMD_ATTR_TABLE],
		       0);
	if (ret)
		goto out;


	nr = __ip_acc_table_get(uitb.table_name);

	if ( nr == -1)
		ret = -ESRCH;
	else if ( nr == 0 )
		ret = -EPERM;
	else
		ret = ip_acc_del_table(nr);


out:
	spin_unlock_bh(&ip_acc_lock);
	LeaveFunction();
	dLog("%s ret: %d\n",__func__,  ret);
	return ret;
	
}



static int ip_acc_genl_add_table(struct sk_buff *skb, struct genl_info *info){
	int nr = -1;
	struct ip_acc_table_user_kern uitb;
	
	int ret = 0, cmd;
	EnterFunction();

	cmd = info->genlhdr->cmd;

	spin_lock_bh(&ip_acc_lock);
	dLog("IPACCOUNT: %s cmd: (%d)\n",
		__func__, cmd);


	ret = ip_acc_genl_parse_table(&uitb,
		       info->attrs[IPACC_CMD_ATTR_TABLE],
		       1);
	if (ret)
		goto out;


	nr = __ip_acc_table_get(uitb.table_name);

	if ( nr == -1)
		ret = ip_acc_add_table(&nr, &uitb);
	else
		ret = -EEXIST;


out:
	spin_unlock_bh(&ip_acc_lock);
	LeaveFunction();
	dLog("%s ret: %d\n",__func__,  ret);
	return ret;
	
}

static int ip_acc_genl_fill_table(struct sk_buff *skb,
				   int nr)
{
	struct nlattr *nl_table;
	struct ip_acc_table *itb;
	EnterFunction();

	nl_table = nla_nest_start(skb, IPACC_CMD_ATTR_TABLE);
	if (!nl_table)
		return -EMSGSIZE;

	itb = &ip_acc_tables[nr]; 
	NLA_PUT_U32(skb, IPACC_TABLE_ATTR_NET_IP, itb->ip);
	NLA_PUT_U32(skb, IPACC_TABLE_ATTR_NET_MASK, itb->netmask);
	NLA_PUT_STRING(skb, IPACC_TABLE_ATTR_NAME, itb->name);
	NLA_PUT_U32(skb, IPACC_TABLE_ATTR_NR, nr);

	nla_nest_end(skb, nl_table);
	return 0;
	
nla_put_failure:
	nla_nest_cancel(skb, nl_table);
	return -EMSGSIZE;
		
}



static int ip_acc_genl_dump_table(struct sk_buff *skb,
				   int nr,
				   struct netlink_callback *cb)
{
	void *hdr;
	EnterFunction();

	hdr = genlmsg_put(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,
			  &ip_acc_genl_family, NLM_F_MULTI,
			  IPACC_CMD_GET_TABLE_NAMES);
	if (!hdr)
		return -EMSGSIZE;

	if (ip_acc_genl_fill_table(skb, nr) < 0)
		goto nla_put_failure;

	return genlmsg_end(skb, hdr);

nla_put_failure:
	genlmsg_cancel(skb, hdr);
	return -EMSGSIZE;
}


static int ip_acc_genl_dump_tables(struct sk_buff *skb,
		struct netlink_callback *cb)
{
	int idx = 0, i;
	int start = cb->args[0];
	EnterFunction();

	spin_lock_bh(&ip_acc_lock);

	for(i = 0; i < ACCOUNT_MAX_TABLES; i++){
		if (ip_acc_tables[i].name[0] != 0){
			if (++idx <= start)
				continue;

			if (ip_acc_genl_dump_table(skb, i, cb) < 0) {
				idx--;
				goto nla_put_failure;
			}
		}
	}

nla_put_failure:
	spin_unlock_bh(&ip_acc_lock);
	cb->args[0] = idx;

	return skb->len;

}


/*
static int ip_acc_genl_find_table(struct nlattr *nla)
{
	struct ip_acc_table_user_kern uitb;
	int ret;

	ret = ip_acc_genl_parse_table(&uitb, nla, 0);
	if (ret)
		return -1;

	return __ip_acc_table_get(uitb.table_name);
}
*/

static int ip_acc_genl_fill_ip(struct sk_buff *skb,
				   struct ip_acc_handle_ip *hip)
{
	struct nlattr *nl_ip;
	EnterFunction();

	nl_ip = nla_nest_start(skb, IPACC_CMD_ATTR_IP);
	if (!nl_ip)
		return -EMSGSIZE;


	NLA_PUT_U32(skb, IPACC_IP_ATTR_IP, hip->ip);
	NLA_PUT_U32(skb, IPACC_IP_ATTR_SRC_PACKETS, hip->src_packets);
	NLA_PUT_U32(skb, IPACC_IP_ATTR_SRC_BYTES, hip->src_bytes);
	NLA_PUT_U32(skb, IPACC_IP_ATTR_DST_PACKETS, hip->dst_packets);
	NLA_PUT_U32(skb, IPACC_IP_ATTR_DST_BYTES, hip->dst_bytes);

	nla_nest_end(skb, nl_ip);
	return 0;
	
nla_put_failure:
	nla_nest_cancel(skb, nl_ip);
	return -EMSGSIZE;
		
}


static int ip_acc_genl_dump_ip(struct sk_buff *skb,
				   struct ip_acc_handle_ip *hip,
				   struct netlink_callback *cb)
{
	void *hdr;
	EnterFunction();

	hdr = genlmsg_put(skb, NETLINK_CB(cb->skb).pid, cb->nlh->nlmsg_seq,
			  &ip_acc_genl_family, NLM_F_MULTI,
			  IPACC_CMD_GET_IPS);
	if (!hdr)
		return -EMSGSIZE;

	if (ip_acc_genl_fill_ip(skb, hip) < 0)
		goto nla_put_failure;

	return genlmsg_end(skb, hdr);

nla_put_failure:
	genlmsg_cancel(skb, hdr);
	return -EMSGSIZE;
}


// for debug , block mode
static int ip_acc_genl_dump_ips(struct sk_buff *skb,
		struct netlink_callback *cb)
{
	int idx = 0, handle;
	int start = cb->args[0];
	uint8_t depth;
	uint32_t net_ip, i, j, k, offset;
	struct ip_acc_handle_ip handle_ip;
	struct nlattr *attrs[IPACC_CMD_ATTR_MAX + 1];
	
	EnterFunction();


	/* Try to find the service for which to dump destinations */
	if (nlmsg_parse(cb->nlh, GENL_HDRLEN, attrs,
			IPACC_CMD_ATTR_MAX, ip_acc_cmd_policy)){
		return skb->len;
	}


	if (attrs[IPACC_CMD_ATTR_HANDLE_NR])
		handle = nla_get_u32(attrs[IPACC_CMD_ATTR_HANDLE_NR]);
	else
		goto out_err; 

	if (handle >= ACCOUNT_MAX_HANDLES) {
		goto out_err;
	}

	down(&ip_acc_userspace_mutex);

	
	//ret = ip_acc_handle_get_data(handle.handle_nr, user);
	if (ip_acc_handles[handle].data == NULL) {
		dLog("ACCOUNT: handle %u is NULL: Contains no data\n", handle);
		goto out_err;
	}
	
	net_ip = ntohl(ip_acc_handles[handle].ip);
	depth = ip_acc_handles[handle].depth;


	if (depth == 0) {
		struct ip_acc_mask_24 *network = ip_acc_handles[handle].data;
		for (i = 0; i < 255; i++) {
			if (++idx <= start)
				continue;
			if (network->ip[i].src_packets || network->ip[i].dst_packets) {
				handle_ip.ip = net_ip | i;
				handle_ip.src_packets = network->ip[i].src_packets;
				handle_ip.src_bytes = network->ip[i].src_bytes;
				handle_ip.dst_packets = network->ip[i].dst_packets;
				handle_ip.dst_bytes = network->ip[i].dst_bytes;

				if (ip_acc_genl_dump_ip(skb, &handle_ip, cb) < 0) {
					idx--;
					goto nla_put_failure;
				}
			}
		}
	} else if (depth == 1) {
		struct ip_acc_mask_16 *network_16 = ip_acc_handles[handle].data;
		struct ip_acc_mask_24 *network;
		for (j = 0; j <= 255; j++) {
			if ((network  = network_16->mask_24[j])){
				offset = j << 8;
				for (i = 0; i < 255; i++) {
					if (++idx <= start)
						continue;
					if (network->ip[i].src_packets 
						|| network->ip[i].dst_packets) {
						handle_ip.ip = 
							net_ip | offset | i;
						handle_ip.src_packets =
							network->ip[i].src_packets;
						handle_ip.src_bytes =
							network->ip[i].src_bytes;
						handle_ip.dst_packets =
							network->ip[i].dst_packets;
						handle_ip.dst_bytes =
							network->ip[i].dst_bytes;

						if (ip_acc_genl_dump_ip(skb, 
							&handle_ip, cb) < 0) {
							idx--;
							goto nla_put_failure;					
						}
					}
				}
			}

		}	
	} else if (depth == 2) {
		struct ip_acc_mask_8 *network_8 = ip_acc_handles[handle].data;
		struct ip_acc_mask_16 *network_16;
		struct ip_acc_mask_24 *network; 		

		for (k = 0; k <= 255; k++) {
		if((network_16 = network_8->mask_16[k])){
		for (j = 0; j <= 255; j++) {
			if ((network = network_16->mask_24[j])){
				offset = (j << 8) | (k << 16); 
				for (i = 0; i < 255; i++) {
					if (++idx <= start)
						continue;
					if (network->ip[i].src_packets ||
						network->ip[i].dst_packets) {
						handle_ip.ip = 
							net_ip | offset | i;
						handle_ip.src_packets =
							network->ip[i].src_packets;
						handle_ip.src_bytes =
							network->ip[i].src_bytes;
						handle_ip.dst_packets =
							network->ip[i].dst_packets;
						handle_ip.dst_bytes = 
							network->ip[i].dst_bytes;
		
						if (ip_acc_genl_dump_ip(skb, 
							&handle_ip, cb) < 0) {
							idx--;
							goto nla_put_failure;					
						}
					}
				}
			}
		}
		}
		}
	}

	ip_acc_handle_free(handle);

nla_put_failure:
	cb->args[0] = idx;

out_err:
	up(&ip_acc_userspace_mutex);
	return skb->len;

}


static struct genl_ops ip_acc_genl_ops[] __read_mostly = {
	{
	.cmd = IPACC_CMD_ADD_TABLE,
	.flags = GENL_ADMIN_PERM,
	.policy = ip_acc_cmd_policy,
	.doit = ip_acc_genl_add_table,
	},
	{
	.cmd = IPACC_CMD_SET_TABLE,
	.flags = GENL_ADMIN_PERM,
	.policy = ip_acc_cmd_policy,
	.doit = ip_acc_genl_set_table,
	},
	{
	.cmd = IPACC_CMD_DEL_TABLE,
	.flags = GENL_ADMIN_PERM,
	.policy = ip_acc_cmd_policy,
	.doit = ip_acc_genl_del_table,
	},	
	{
	.cmd = IPACC_CMD_GET_IPS_PRE,
	.flags = GENL_ADMIN_PERM,
	.policy = ip_acc_cmd_policy,
	.doit = ip_acc_genl_get_cmd,
	},
	{
	.cmd = IPACC_CMD_GET_IPS_PRE_FLUSH,
	.flags = GENL_ADMIN_PERM,
	.policy = ip_acc_cmd_policy,
	.doit = ip_acc_genl_get_cmd,
	},	
	{
	.cmd = IPACC_CMD_GET_TABLE_NAMES,
	.flags = GENL_ADMIN_PERM,
	.policy = ip_acc_cmd_policy,
	.dumpit = ip_acc_genl_dump_tables,
	},
	{
	.cmd = IPACC_CMD_GET_IPS,
	.flags = GENL_ADMIN_PERM,
	.policy = ip_acc_cmd_policy,
	.dumpit = ip_acc_genl_dump_ips,
	},
};

static int __init ip_acc_genl_register(void)
{
	return genl_register_family_with_ops(&ip_acc_genl_family,
					     ip_acc_genl_ops,
					     ARRAY_SIZE(ip_acc_genl_ops));
}

static void ip_acc_genl_unregister(void)
{
	genl_unregister_family(&ip_acc_genl_family);
}








static int __init account_init(void)
{
	int ret;
 	int nr = 0;
	struct ip_acc_table_user_kern uitb = {
		.net_ip = LAN_DEFAULT_NET,
		.net_mask = LAN_DEFAULT_MASK,
		.table_name = LAN_DEFAULT_NAME,
		};
	
	EnterFunction();

	sema_init(&ip_acc_userspace_mutex, 1);

	if ((ip_acc_tables = kmalloc(ACCOUNT_MAX_TABLES *
		sizeof(struct ip_acc_table), GFP_KERNEL)) == NULL) {
		pr_err("IPACCOUNT: Out of memory allocating account_tables structure");
		goto error_cleanup;
	}
	memset(ip_acc_tables, 0,
		ACCOUNT_MAX_TABLES * sizeof(struct ip_acc_table));

	if ((ip_acc_handles =
	    kmalloc(ACCOUNT_MAX_HANDLES *
	    sizeof(struct ip_acc_handle), GFP_KERNEL)) == NULL) {
		printk("ACCOUNT: Out of memory allocating account_handles structure");
		goto error_cleanup;
	}
	memset(ip_acc_handles, 0,
		ACCOUNT_MAX_HANDLES * sizeof(struct ip_acc_handle));



	ret = ip_acc_genl_register();
	if (ret) {
		eLog("%s error", __func__);
		goto error_cleanup;
	}

	//register_skb_accounter(skb_rx_accounter, skb_tx_accounter);
	
#ifdef HNDCTF
	ctf_skb_rx_accounter = _skb_rx_accounter;
#endif
	skb_rx_accounter = _skb_rx_accounter;
	skb_tx_accounter = _skb_tx_accounter;


	spin_lock_bh(&ip_acc_lock);
	ret = ip_acc_add_table(&nr, &uitb);
	spin_unlock_bh(&ip_acc_lock);


	/*
	* A non 0 return means init_module failed; module can't be loaded.
	*/
	return 0;


error_cleanup:
	if (ip_acc_tables)
		kfree(ip_acc_tables);
	if (ip_acc_handles)
		kfree(ip_acc_handles);	
	return -EINVAL;
    
}

static void __exit account_exit(void)
{
	EnterFunction();
	
	dLog("Goodbye world 1.\n");
	//unregister_skb_accounter();
#ifdef HNDCTF
	ctf_skb_rx_accounter = NULL;
#endif
	skb_rx_accounter = NULL;
	skb_tx_accounter = NULL;

	ip_acc_genl_unregister();
	ip_acc_destroy();
	if (ip_acc_tables)
		kfree(ip_acc_tables);
	if (ip_acc_handles)
		kfree(ip_acc_handles);		
	
	LeaveFunction();	
}


module_init(account_init);
module_exit(account_exit);
MODULE_DESCRIPTION("ip account: per-IP accounting for large prefixes");
MODULE_AUTHOR("yu bo <yubo@xiaomi.com>");
MODULE_ALIAS("ip_ACCOUNT");
MODULE_LICENSE("GPL");



